# Paystack assessment project

This project serves as part of the interview process at Paystack.

# Problem statement

```
Task

Your task is to build a small shopping cart application.
Assume that you have a list of products in a category (eg. food or clothing)
which contain a set of standard attributes (sku, selling price, stock level, expiration date etc.)
which a user can:

1. add to,
2. remove from and
3. edit inside a cart.

Parameters

You are required to use NodeJS (using either JavaScript or TypeScript)

You are to make use of a MySQL database

We do not require the use of any UI - interacting via a tool like PostMan/curl is sufficient to interrogate the API.

You must be able to walk us through the solution and it should be sufficiently documented.

This solution needs to be built in a private GitHub repository so that we can track the evolution of the solution and it's commit history

Bonus points

For optional bonus points, feel free to introduce any addition to the solution that you think demonstrates your abilities as an experienced engineer.
This could be a specific technology, a solution design consideration, some performance optimization etc. This is a chance for you to stand out.
```

# Solution plan

## Architectural design

### Technology used

Assuming the above mentioned , [NodeJS](https://nodejs.org/en/) and [MySQL](https://www.mysql.com/) are installed.

The technology used are as follows:

1. [Prisma](https://www.prisma.io/) an open source next-generation ORM
2. [Graphql-Yoga](https://github.com/dotansimha/graphql-yoga) a fully-featured GraphQL Server with focus on easy setup, performance & great developer experience
3. [Graphql-Tools](https://github.com/ardatan/graphql-tools) a tool for mananging GraphQL schema

### Folders and files structure

```
src|
  resolvers|
    mutations|
      cartProduct|
        addProductToCart.ts
        editProductInCart.ts
        removerProductFromCart.ts
      ...
    queries|
      cartProduct|
        userProductsOnCart
        ...
    Mutation.ts
    Query.ts
    index.ts
    types.ts

  typeDefs|
    general|
      type.typedefs.graphql
      ...
    mutations|
      mutation.typedefs.graphql
    queries:
      query.typedefs.graphql
    index.ts

prisma:
  migrations:
    ... (These files are autogenerated by prisma migration)
  schema.prisma
...
```

### Database schema

Our database will be consisting of the following tables:

1. `Category` (You will need to add category accordingly)
2. `Product` (You will need to add product accordingly)
3. `CategoryProduct` (You will need to add category product accordingly)
4. `User` (You will need to add user accordingly)
5. `ProductOnCart` (This will be driven by the functionality of adding, editing and removing product from cart as required)

The entity relationship is as follows:

1. A Product belongs to Categories
2. A category has many products
3. A User can have Product/s
4. ProductOnCart details the User's Product/s in a Cart

This can be visualized in the prisma schema format as follows:

```prisma
model Category {
  id       Int               @id @default(autoincrement())
  category String            @db.VarChar(255)
  products CategoryProduct[]
}

model Product {
  id             Int               @id @default(autoincrement())
  name           String
  price          Float
  sku            String            @unique
  stock          Float
  expirationDate DateTime
  categories     CategoryProduct[]
}

model CategoryProduct {
  id             Int             @id @default(autoincrement())
  cotegory       Category        @relation(fields: [categoryId], references: [id])
  categoryId     Int
  product        Product         @relation(fields: [productId], references: [id])
  productId      Int
  productsOnCart ProductOnCart[]

  @@unique([categoryId, productId])
}

model User {
  id           Int             @id @default(autoincrement())
  email        String          @unique
  name         String
  cartProducts ProductOnCart[]
}

model ProductOnCart {
  id                Int             @id @default(autoincrement())
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  quantity          Float
  totalAmount       Float
  user              User            @relation(fields: [userId], references: [id])
  userId            Int
  categoryProduct   CategoryProduct @relation(fields: [categoryProductId], references: [id])
  categoryProductId Int
}
```

# Setting up for development

## Cloning the code

To clone, you need to run the following command (assuming that `git` is installed on your machine.

```bash
git clone https://github.com/chynamyerz/paystack-assessment.git
```

A directory of name `paystack-assessment` with the code will be created.

You will need to install the required Node packages. Node and [yarn](https://yarnpkg.com/) must be installed on your machine.

```sh
cd paystack-assessment
yarn
```

You will also need to create a `.env` file which will host environment variables. The required variable for this project is _DATABASE_URL_ which contains a url for connecting to the database.

| Variable     | Description                       | Example                                    |
| ------------ | --------------------------------- | ------------------------------------------ |
| DATABASE_URL | URL for mysql database connection | mysql://username:password@host:3306/dbname |

You will need to map the data model to the database schema, execute the following command:

```sh
yarn prisma:migrate:init
```

You can then start the server by executing the following command:

```sh
yarn dev
```

Once the server has started successfuly, please nevigate to [http://localhost:4000/](http://localhost:4000/) which will take you to the playground for performing the availble queries and mutations.

## Workflow policy

No code changes should be pushed to either the development or the master branch.
Instead, create a new local branch from the development branch, make your changes and push the branch to the Github repository.

Afterwards, make a pull request in Github from the new branch to the development branch.

In principle, someone else should check the pull request, and approve or reject for further changes.

Once work on a branch other than master or development is done, that branch should be merged to development and be deleted.
